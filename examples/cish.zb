
%%

%code requires {
	#include <stdio.h>
}

// NFA string literal, parenthesis: "literal", (DFA $1)
// NFA (not) one-of-many (in range): [(^) <$1>, <$2>, <$3> (- <$4>), ...];
// NFA multiplicities <$1>?, <$1>+, <$1>*, <$1>{a, b};
// NFA concatenation: <$1> <$2> ...
// NFA -> DFA // (and simplication)
// DFA boolean-not: !<$1>
// DFA boolean-and: <$1> & <$2> & ...
// DFA boolean-and: <$1> ^ <$2> ^ ...
// DFA boolean-or: <$1> | <$2> | ...
// DFA simplication again

// LRP string literal, regex, parenthesis: "token", `DFA $1`, (LRP $1)
// LRP reduction-rule multiplicities: <$1>?, <$1>+, <$1>*, <$1>{a, b};
// LRP reduction-rule concatenation: <$1> <$2> ...;
// LRP reduction-rule divider: <$1> | <$2> ... ;

// there will still have to be a tokenizer.
// the tokenizer uses the current state of the parser to look up
// the appropriate state machine to use. Given this state machine,
// the current character, and the current state, it can lookup the next
// state. When the state returns a token enum value, it's done, feed it
// to parser state machine.

// The "appropriate state machine" is generated by unionning the state machines
// for recognizing the tokens that would be acceptable at the point in the
// parsing. Some strings could still theoretically match multiple tokens:
	// literal overlaps with literal: unreachable.
	// literal/regex overlaps with regex/literal: literals are matched first.
	// regex overlaps with regex: error message: "ambiguous token"

%contextless whitespace: /[' ', '\n', '\t']+/;

%contextless singleline_comment: /"//" [^'\n']* "\n"/;

%contextless multiline_comment: "/*" multiline_skip ( multiline_comment multiline_skip )* "*/";
multiline_skip: /!(.*"*/") && !(.*"/*")/ ;

identifier | typename: /['a'-'z','A'-'Z'] ['a'-'z','A'-'Z']* / {
	assert(!"lookup string in scope");
	return // t_identifier or t_typename;
};

type: typename
	| "enum"   "{" (identifier (',' identifier)*)? "}"
	| "union"  "{" (type identifier (',' identifier)* ';')* "}"
	| "struct" "{" (type identifier (',' identifier)* ';')* "}"
	;

highest
	: identifier
	| /['0'-'9']+/
	| '(' expression ')'
	| '(' type ')' '{' (expression (',' expression)*)? '}'
	| highest '(' ')'
	| highest '[' expression ']'
	| highest '.' identifier
	| highest /'-'+'>'/ identifier
	;

unary_expression: ;

// ...

logical_or_expression
	: logical_and_expression
	| logical_or_expression "==" logical_and_expression
	| logical_or_expression "!=" logical_and_expression
	;

logical_or_expression: logical_and_expression | logical_or_expression "&" logical_and_expression ;

logical_or_expression: logical_and_expression | logical_or_expression "^" logical_and_expression ;

logical_or_expression: logical_and_expression | logical_or_expression "|" logical_and_expression ;

logical_or_expression: logical_and_expression | logical_or_expression "&&" logical_and_expression ;

logical_or_expression: logical_and_expression | logical_or_expression "||" logical_and_expression ;

ternary_expression
	: logical_or_expression
	| logical_or_expression '?' expression ':' ternary_expression
	;

assignment_expression
	: ternary_expression
	| unary_expression   "=" ternary_expression
	| unary_expression  "+=" ternary_expression
	| unary_expression  "-=" ternary_expression
	| unary_expression  "*=" ternary_expression
	| unary_expression  "/=" ternary_expression
	| unary_expression  "%=" ternary_expression
	| unary_expression  "&=" ternary_expression
	| unary_expression  "^=" ternary_expression
	| unary_expression  "|=" ternary_expression
	| unary_expression "<<=" ternary_expression
	| unary_expression ">>=" ternary_expression
	;

expression: assignment_expression (',' assignment_expression)*;

%start start: expression* {
	printf("'%c':'%c'\n", $1, $3);
	puts("nice.");
};

%%

















