
// vim: ts=4

// %code requires {
// 	#include <stdio.h>
// }

%include <abc.zb>

// charset: char literal: 'c', (charset $1)
// charset: set-complement: ~ <$1>
// charset: set-range: <$1> - <$2>
// charset: set-intersect: <$1> & <$2> ...
// charset: set-difference: <$1> ^ <$2> ...
// charset: set-union: <$1> '|'? <$2> ...

//    -?FA string literal, parenthesis: "literal", [char-set $1], (?FA $1)
// DFA-DFA prefixes: !<$1>
// ?FA-NFA suffixes: <$1>?, <$1>+, <$1>*, <$1>{a, b}
// ?FA-NFA concatenation: <$1> <$2> ...
// DFA-DFA boolean-and : <$1> & <$2> & ...
// ?FA-?FA boolean-or  : <$1> | <$2> | ...

// LRP charater/string literal, regex, parenthesis: "token", `DFA $1`, (LRP $1)
// LRP reduction-rule multiplicities: <$1>?, <$1>+, <$1>*, <$1>{a, b};
// LRP reduction-rule concatenation: <$1> <$2> ...;
// LRP reduction-rule divider: <$1> | <$2> ... ;

// there will still have to be a tokenizer.
// the tokenizer uses the current state of the parser to look up
// the appropriate state machine to use. Given this state machine,
// the current character, and the current state, it can lookup the next
// state. When the state returns a token enum value, it's done, feed it
// to parser state machine.

%start start;

start : `abc & (..)*` ":" `['w' - 'y']*` "." {
		printf("'%s':'%s'\n", $1, $3);
		puts("nice.");
	} | `abc & (...)*` ":"+ `[~(~('w'-'y') & ~('x'-'z')) & ~'w']` "!" {
		printf("'%s':'%s'\n", $1, $3);
		puts("nice!");
	} | "abc" "?"? {
		puts("nice?");
	} | (
		a: 'a' (  | b | c) 'a';
		b: 'b' (a |   | c) 'b';
		c: 'c' (a | b |  ) 'c';
		       (    b | c)
		       (a | b | c)*
	)   {
		puts("palindromatic!");
	};




























