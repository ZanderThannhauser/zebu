
// vim: ts=4

// %code requires {
// 	#include <stdio.h>
// }

%include <abc.zb>

// DFA string literal, parenthesis: "literal", (DFA $1)
// DFA prefixes: !<$1>
// NFA suffixes <$1>?, <$1>+, <$1>*, <$1>{a, b}
// NFA range: <$1> '...' <$2>
// NFA concatenation: <$1> <$2> ...
// NFA -> DFA   // (and simplication)
// DFA boolean-cmp (and simplication): <$1> {<,>,<=,>=,==,!=} <$2> ... (python-style)
// DFA boolean-and (and simplication): <$1> & <$2> & ...
// DFA boolean-or  (and simplication): <$1> | <$2> | ...
// DFA boolean-?:  (and simplication): <$1> if ... else <$3>

// LRP charater/string literal, regex, parenthesis: "token", `DFA $1`, (LRP $1)
// LRP reduction-rule multiplicities: <$1>?, <$1>+, <$1>*, <$1>{a, b};
// LRP reduction-rule concatenation: <$1> <$2> ...;
// LRP reduction-rule divider: <$1> | <$2> ... ;

// there will still have to be a tokenizer.
// the tokenizer uses the current state of the parser to look up
// the appropriate state machine to use. Given this state machine,
// the current character, and the current state, it can lookup the next
// state. When the state returns a token enum value, it's done, feed it
// to parser state machine.

%start start;

start: `abc & (..)*` ":" `"w" ... "y"` "." {
		printf("'%s':'%s'\n", $1, $3);
		puts("nice.");
	} | `abc & (...)*` ":" `"x" ... "z"` "!" {
		printf("'%s':'%s'\n", $1, $3);
		puts("nice!");
	};


















