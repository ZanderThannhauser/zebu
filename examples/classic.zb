
// vim: ts=4

// %code requires {
// 	#include <stdio.h>
// }

%include <abc.zb>

// charset: char literal: 'c', (charset $1)
// charset: set-complement: ~ <$1>
// charset: set-range: <$1> - <$2>
// charset: set-intersect: <$1> & <$2> ...
// charset: set-symmetric-difference: <$1> ^ <$2> ...
// charset: set-union: <$1> ['|',',']? <$2> ...

//    -?FA string literal, parenthesis: "literal", [char-set $1], (?FA $1)
// DFA-DFA prefixes: !<$1>
// ?FA-NFA suffixes: <$1>?, <$1>+, <$1>*, <$1>{a, b}
// ?FA-NFA concatenation: <$1>   <$2>   ...
// DFA-DFA boolean-and  : <$1> & <$2> & ...
// ?FA-?FA boolean-or   : <$1> | <$2> | ...

// LRP charater/string literal, regex, parenthesis: "token", `DFA $1`, (LRP $1)
// LRP multiplicities: <$1>?, <$1>+, <$1>*, <$1>{a, b};
// LRP concatenation: <$1> <$2> ...;
// LRP or: <$1> | <$2> ... ;

// there will still have to be a tokenizer.
// the tokenizer uses the current state of the parser to look up
// the appropriate state machine to use. Given this state machine,
// the current character, and the current state, it can lookup the next
// state. When the state returns a token enum value, it's done, feed it
// to parser state machine.

%start start;

[wy]: 'w' - 'y';

start: "abc"                                                  "?"?
	 | `abc & (..)*`  ":"    `![~wy]*`                        "."
	 | `abc & (...)*` ":"+ `[~(~(wy) & ~('x' - 'z')) & ~'w']` "!"
	 | ([a]:  'a';
	    `a`: [ a,             'A'];
		 a :  `a` (  | b | c) `a`;
		 b :  'b' (a |   | c) 'b';
		 c :  'c' (a | b |  ) 'c';
		          (    b | c)
		          (a | b | c)* ) ;




























