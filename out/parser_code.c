
#include "parser_code.h"

const char parser_code[] = ""

	"#include <stdlib.h>" "\n"
	"#include <stddef.h>" "\n"
	"#include <assert.h>" "\n"
	"#include <string.h>" "\n"
	"struct zebu_state {" "\n"
	"\t""struct { unsigned* data, n, cap; } y;" "\n"
	"\t""struct { unsigned char* data, n, cap; } l;" "\n"
	"\t""unsigned lstate, t;" "\n"
	"};" "\n"
	"static void push(struct zebu_state* this, unsigned ystate) {" "\n"
	"\t""if (this->y.n + 1 >= this->y.cap) {" "\n"
	"\t""\t""this->y.cap = this->y.cap << 1 ?: 1;" "\n"
	"\t""\t""this->y.data = realloc(this->y.data, sizeof(*this->y.data) * this->y.cap);" "\n"
	"\t""}" "\n"
	"\t""this->y.data[this->y.n++] = ystate;" "\n"
	"}" "\n"
	"static void append(struct zebu_state* this, const unsigned char* text, size_t length) {" "\n"
	"\t""while (this->l.n + length >= this->l.cap) {" "\n"
	"\t""\t""this->l.cap = this->l.cap << 1 ?: 1;" "\n"
	"\t""\t""this->l.data = realloc(this->l.data, this->l.cap);" "\n"
	"\t""}" "\n"
	"\t""memcpy(this->l.data + this->l.n, text, length);" "\n"
	"\t""this->l.n += length;" "\n"
	"}" "\n"
	"struct zebu_state* new_zebu_state() {" "\n"
	"\t""struct zebu_state* this = malloc(sizeof(*this));" "\n"
	"\t""assert(this);" "\n"
	"\t""this->y.data = NULL, this->y.n = 0, this->y.cap = 0;" "\n"
	"\t""this->l.data = NULL, this->l.n = 0, this->l.cap = 0;" "\n"
	"\t""this->lstate = 1, this->t = 0;" "\n"
	"\t""push(this, 1);" "\n"
	"\t""return this;" "\n"
	"}" "\n"
	"void zebu_reset(struct zebu_state* this) {" "\n"
	"\t""this->y.n = 0;" "\n"
	"\t""this->l.n = 0;" "\n"
	"\t""this->lstate = 1;" "\n"
	"\t""push(this, 1);" "\n"
	"}" "\n"
	"#define N(array) (sizeof(array) / sizeof(*array))" "\n"
	"static void process_token(struct zebu_state* this, unsigned t) {" "\n"
	"\t""unsigned b, d, y = this->y.data[this->y.n - 1];" "\n"
	"\t""while (!(y < N(zebu_shifts) && t < N(*zebu_shifts) && (b = zebu_shifts[y][t]))) {" "\n"
	"\t""\t""if (y < N(zebu_reduces) && t < N(*zebu_reduces) && (b = zebu_reduces[y][t])) {" "\n"
	"\t""\t""\t""unsigned s = t;" "\n"
	"\t""\t""\t""while (!(1" "\n"
	"\t""\t""\t""\t"" && y < N(zebu_shifts) && b < N(*zebu_shifts) && (d = zebu_shifts[y][b])" "\n"
	"\t""\t""\t""\t"" && b < N(zebu_firsts) && s < N(*zebu_firsts) && (    zebu_firsts[b][s]))) {" "\n"
	"\t""\t""\t""\t""if (this->y.n == 1) return;" "\n"
	"\t""\t""\t""\t""s = this->y.data[--this->y.n - 1];" "\n"
	"\t""\t""\t""\t""y = this->y.data[--this->y.n - 1];" "\n"
	"\t""\t""\t""}" "\n"
	"\t""\t""\t""push(this, b), push(this, d), y = d;" "\n"
	"\t""\t""} else {" "\n"
	"\t""\t""\t""assert(!\"TODO\");" "\n"
	"\t""\t""\t""exit(1);" "\n"
	"\t""\t""}" "\n"
	"\t""}" "\n"
	"\t""push(this, t), push(this, b), y = b;" "\n"
	"}" "\n"
	"void zebu_parse(struct zebu_state* this, const unsigned char* text, size_t length) {" "\n"
	"\t""unsigned c, l = this->lstate;" "\n"
	"\t""unsigned a, b, i, n, f, t = this->t;" "\n"
	"\t""i = this->l.n;" "\n"
	"\t""append(this, text, length);" "\n"
	"\t""for (n = this->l.n, f = 0; i < n;) {" "\n"
	"\t""\t""c = this->l.data[i];" "\n"
	"\t""\t""a = (c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0) ?: (l < N( zebu_defaults) ? zebu_defaults[l] : 0);" "\n"
	"\t""\t""b = (l < N(zebu_accepts) ? zebu_accepts[l] : 0);" "\n"
	"\t""\t""if (a) {" "\n"
	"\t""\t""\t""if (b)" "\n"
	"\t""\t""\t""\t""l = a, t = b, f = i++;" "\n"
	"\t""\t""\t""else" "\n"
	"\t""\t""\t""\t""l = a, i++;" "\n"
	"\t""\t""} else if (b) {" "\n"
	"\t""\t""\t""process_token(this, b);" "\n"
	"\t""\t""\t""l = zebu_starts[this->y.data[this->y.n - 1]], f = i + 1, t = 0;" "\n"
	"\t""\t""} else if (t) {" "\n"
	"\t""\t""\t""process_token(this, t);" "\n"
	"\t""\t""\t""l = zebu_starts[this->y.data[this->y.n - 1]], i = f, t = 0;" "\n"
	"\t""\t""} else {" "\n"
	"\t""\t""\t""assert(!\"TODO\");" "\n"
	"\t""\t""}" "\n"
	"\t""}" "\n"
	"\t""memcpy(this->l.data, this->l.data + f, this->l.n = n - f);" "\n"
	"\t""this->t = t;" "\n"
	"\t""this->lstate = l;" "\n"
	"}" "\n"
	"void zebu_parse_EOF(struct zebu_state* this) {" "\n"
	"\t""unsigned i, n, l = this->lstate;" "\n"
	"\t""unsigned a, b, c, f = 0, t = this->t;" "\n"
	"\t""for (i = this->l.n, n = i; ; ) {" "\n"
	"\t""\t""assert(i <= n);" "\n"
	"\t""\t""if (i < n) {" "\n"
	"\t""\t""\t""c = this->l.data[i];" "\n"
	"\t""\t""\t""a = (c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0) ?: (l < N( zebu_defaults) ? zebu_defaults[l] : 0);" "\n"
	"\t""\t""} else a = 0;" "\n"
	"\t""\t""b = (l < N(zebu_accepts) ? zebu_accepts[l] : 0);" "\n"
	"\t""\t""if (a) {" "\n"
	"\t""\t""\t""if (b)" "\n"
	"\t""\t""\t""\t""l = a, t = b, f = i++;" "\n"
	"\t""\t""\t""else" "\n"
	"\t""\t""\t""\t""l = a, i++;" "\n"
	"\t""\t""} else if (b) {" "\n"
	"\t""\t""\t""process_token(this, b);" "\n"
	"\t""\t""\t""l = zebu_starts[this->y.data[this->y.n - 1]], f = i + 1, t = 0;" "\n"
	"\t""\t""\t""if (f >= n) break;" "\n"
	"\t""\t""} else if (t) {" "\n"
	"\t""\t""\t""process_token(this, t);" "\n"
	"\t""\t""\t""l = zebu_starts[this->y.data[this->y.n - 1]], i = f, t = 0;" "\n"
	"\t""\t""} else {" "\n"
	"\t""\t""\t""assert(!\"TODO\");" "\n"
	"\t""\t""}" "\n"
	"\t""}" "\n"
	"\t""process_token(this, 1);" "\n"
	"}" "\n"
	"void free_zebu_state(struct zebu_state* this) {" "\n"
	"\t""free(this->y.data);" "\n"
	"\t""free(this->l.data);" "\n"
	"\t""free(this);" "\n"
	"}" "\n"

"";

const char parser_debug[] = ""

	"#include <stdlib.h>" "\n"
	"#include <stddef.h>" "\n"
	"#include <assert.h>" "\n"
	"#include <stdio.h>" "\n"
	"#include <string.h>" "\n"
	"#include <stdarg.h>" "\n"
	"" "\n"
	"struct zebu_state" "\n"
	"{" "\n"
	"\t""struct { unsigned* data, n, cap; } y;" "\n"
	"\t""struct { unsigned char* data, n, cap; } l;" "\n"
	"\t""unsigned lstate, t;" "\n"
	"};" "\n"
	"" "\n"
	"static void push(struct zebu_state* this, unsigned ystate)" "\n"
	"{" "\n"
	"\t""if (this->y.n + 1 >= this->y.cap)" "\n"
	"\t""{" "\n"
	"\t""\t""this->y.cap = this->y.cap << 1 ?: 1;" "\n"
	"\t""\t""this->y.data = realloc(this->y.data, sizeof(*this->y.data) * this->y.cap);" "\n"
	"\t""}" "\n"
	"\t""" "\n"
	"\t""this->y.data[this->y.n++] = ystate;" "\n"
	"}" "\n"
	"" "\n"
	"static void append(struct zebu_state* this, const unsigned char* text, size_t length)" "\n"
	"{" "\n"
	"\t""while (this->l.n + length >= this->l.cap)" "\n"
	"\t""{" "\n"
	"\t""\t""this->l.cap = this->l.cap << 1 ?: 1;" "\n"
	"\t""\t""this->l.data = realloc(this->l.data, this->l.cap);" "\n"
	"\t""}" "\n"
	"\t""memcpy(this->l.data + this->l.n, text, length);" "\n"
	"\t""this->l.n += length;" "\n"
	"}" "\n"
	"" "\n"
	"static void ddprintf(struct zebu_state* this, const char* fmt, ...)" "\n"
	"{" "\n"
	"\t""for (unsigned i = 0, n = this->y.n; i < n; i++)" "\n"
	"\t""{" "\n"
	"\t""\t""printf(\"%u \", this->y.data[i]);" "\n"
	"\t""}" "\n"
	"\t""" "\n"
	"\t""printf(\"| \");" "\n"
	"\t""" "\n"
	"\t""va_list va;" "\n"
	"\t""va_start(va, fmt);" "\n"
	"\t""vprintf(fmt, va);" "\n"
	"\t""va_end(va);" "\n"
	"}" "\n"
	"" "\n"
	"struct zebu_state* new_zebu_state() {" "\n"
	"\t""struct zebu_state* this = malloc(sizeof(*this));" "\n"
	"\t""assert(this);" "\n"
	"\t""this->y.data = NULL, this->y.n = 0, this->y.cap = 0;" "\n"
	"\t""this->l.data = NULL, this->l.n = 0, this->l.cap = 0;" "\n"
	"\t""this->lstate = 1, this->t = 0;" "\n"
	"\t""push(this, 1);" "\n"
	"\t""return this;" "\n"
	"}" "\n"
	"" "\n"
	"void zebu_reset(struct zebu_state* this) {" "\n"
	"\t""this->y.n = 0;" "\n"
	"\t""this->l.n = 0;" "\n"
	"\t""this->lstate = 1;" "\n"
	"\t""push(this, 1);" "\n"
	"}" "\n"
	"" "\n"
	"#define N(array) (sizeof(array) / sizeof(*array))" "\n"
	"" "\n"
	"static void process_token(struct zebu_state* this, unsigned t) {" "\n"
	"\t""ddprintf(this, \"t == %u\\n\", t);" "\n"
	"\t""" "\n"
	"\t""unsigned b, d, y = this->y.data[this->y.n - 1];" "\n"
	"\t""" "\n"
	"\t""while (!(y < N(zebu_shifts) && t < N(*zebu_shifts) && (b = zebu_shifts[y][t])))" "\n"
	"\t""{" "\n"
	"\t""\t""if (y < N(zebu_reduces) && t < N(*zebu_reduces) && (b = zebu_reduces[y][t]))" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""ddprintf(this, \"b == %u\\n\", b);" "\n"
	"\t""\t""\t""ddprintf(this, \"g == \\\"%s\\\"\\n\", zebu_grammar_names[b]);" "\n"
	"\t""\t""\t""" "\n"
	"\t""\t""\t""unsigned s = t;" "\n"
	"\t""\t""\t""" "\n"
	"\t""\t""\t""while (!(1" "\n"
	"\t""\t""\t""\t"" && y < N(zebu_shifts) && b < N(*zebu_shifts) && (d = zebu_shifts[y][b])" "\n"
	"\t""\t""\t""\t"" && b < N(zebu_firsts) && s < N(*zebu_firsts) && (    zebu_firsts[b][s])))" "\n"
	"\t""\t""\t""{" "\n"
	"\t""\t""\t""\t""if (this->y.n == 1) return;" "\n"
	"\t""\t""\t""\t""s = this->y.data[--this->y.n - 1];" "\n"
	"\t""\t""\t""\t""y = this->y.data[--this->y.n - 1];" "\n"
	"\t""\t""\t""\t""ddprintf(this, \"y == %u\\n\", y);" "\n"
	"\t""\t""\t""}" "\n"
	"\t""\t""\t""" "\n"
	"\t""\t""\t""push(this, b), push(this, d), y = d;" "\n"
	"\t""\t""\t""ddprintf(this, \"y == %u\\n\", y);" "\n"
	"\t""\t""}" "\n"
	"\t""\t""else" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""assert(!\"TODO\");" "\n"
	"\t""\t""\t""exit(1);" "\n"
	"\t""\t""}" "\n"
	"\t""}" "\n"
	"\t""" "\n"
	"\t""push(this, t), push(this, b), y = b;" "\n"
	"}" "\n"
	"" "\n"
	"void zebu_parse(struct zebu_state* this, const unsigned char* text, size_t length) {" "\n"
	"\t""unsigned c, l = this->lstate;" "\n"
	"\t""unsigned a, b, i, n, f, t = this->t;" "\n"
	"\t""" "\n"
	"\t""i = this->l.n;" "\n"
	"\t""" "\n"
	"\t""append(this, text, length);" "\n"
	"\t""" "\n"
	"\t""for (n = this->l.n, f = 0; i < n;)" "\n"
	"\t""{" "\n"
	"\t""\t""c = this->l.data[i];" "\n"
	"\t""\t""" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""unsigned j, s;" "\n"
	"\t""\t""\t""unsigned char escaped[(n - i) * 4 + 1], *e = escaped;" "\n"
	"\t""\t""\t""for (j = i; j < n; j++)" "\n"
	"\t""\t""\t""\t""switch (s = this->l.data[j]) {" "\n"
	"\t""\t""\t""\t""\t""case 'a' ... 'z':" "\n"
	"\t""\t""\t""\t""\t""case 'A' ... 'Z':" "\n"
	"\t""\t""\t""\t""\t""case '0' ... '9':" "\n"
	"\t""\t""\t""\t""\t""case '!':" "\n"
	"\t""\t""\t""\t""\t""case ':':" "\n"
	"\t""\t""\t""\t""\t""case '.':" "\n"
	"\t""\t""\t""\t""\t""case '+':" "\n"
	"\t""\t""\t""\t""\t""case '(': case ')':" "\n"
	"\t""\t""\t""\t""\t""\t""*e++ = s;" "\n"
	"\t""\t""\t""\t""\t""\t""break;" "\n"
	"\t""\t""\t""\t""\t""case '\\n':" "\n"
	"\t""\t""\t""\t""\t""\t""*e++ = '\\\\';" "\n"
	"\t""\t""\t""\t""\t""\t""*e++ = 'n';" "\n"
	"\t""\t""\t""\t""\t""break;" "\n"
	"\t""\t""\t""\t""\t""default:" "\n"
	"\t""\t""\t""\t""\t""\t""printf(\"s = %c\\n\", s);" "\n"
	"\t""\t""\t""\t""\t""\t""assert(!\"TODO\");" "\n"
	"\t""\t""\t""\t""\t""\t""break;" "\n"
	"\t""\t""\t""\t""}" "\n"
	"\t""\t""\t""*e = 0;" "\n"
	"\t""\t""\t""ddprintf(this, \"c == %u \\\"%s\\\"\\n\", c, escaped);" "\n"
	"\t""\t""}" "\n"
	"\t""\t""" "\n"
	"\t""\t""a = (c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0) ?: (l < N( zebu_defaults) ? zebu_defaults[l] : 0);" "\n"
	"\t""\t""b = (l < N(zebu_accepts) ? zebu_accepts[l] : 0);" "\n"
	"\t""\t""" "\n"
	"\t""\t""if (a)" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""if (b)" "\n"
	"\t""\t""\t""{" "\n"
	"\t""\t""\t""\t""l = a, t = b, f = i++;" "\n"
	"\t""\t""\t""\t""ddprintf(this, \"l = %u, t == %u, f = %u (saved)\\n\", l, t, f);" "\n"
	"\t""\t""\t""}" "\n"
	"\t""\t""\t""else" "\n"
	"\t""\t""\t""{" "\n"
	"\t""\t""\t""\t""l = a, i++;" "\n"
	"\t""\t""\t""\t""ddprintf(this, \"l == %u\\n\", l);" "\n"
	"\t""\t""\t""}" "\n"
	"\t""\t""}" "\n"
	"\t""\t""else if (b)" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""process_token(this, b);" "\n"
	"\t""\t""\t""l = zebu_starts[this->y.data[this->y.n - 1]], f = i + 1, t = 0;" "\n"
	"\t""\t""\t""ddprintf(this, \"l == %u, f = %u, t = %u\\n\", l, f, t);" "\n"
	"\t""\t""}" "\n"
	"\t""\t""else if (t)" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""process_token(this, t);" "\n"
	"\t""\t""\t""l = zebu_starts[this->y.data[this->y.n - 1]], i = f, t = 0;" "\n"
	"\t""\t""\t""ddprintf(this, \"l == %u, i = %u, t = %u\\n\", l, i, t);" "\n"
	"\t""\t""}" "\n"
	"\t""\t""else" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""assert(!\"TODO\");" "\n"
	"\t""\t""}" "\n"
	"\t""}" "\n"
	"\t""" "\n"
	"\t""memcpy(this->l.data, this->l.data + f, this->l.n = n - f);" "\n"
	"\t""" "\n"
	"\t""this->t = t;" "\n"
	"\t""" "\n"
	"\t""this->lstate = l;" "\n"
	"}" "\n"
	"" "\n"
	"void zebu_parse_EOF(struct zebu_state* this) {" "\n"
	"\t""unsigned i, n, l = this->lstate;" "\n"
	"\t""unsigned a, b, c, f = 0, t = this->t;" "\n"
	"\t""" "\n"
	"\t""for (i = this->l.n, n = i; ; )" "\n"
	"\t""{" "\n"
	"\t""\t""assert(i <= n);" "\n"
	"\t""\t""" "\n"
	"\t""\t""if (i < n)" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""c = this->l.data[i];" "\n"
	"\t""\t""\t""" "\n"
	"\t""\t""\t""{" "\n"
	"\t""\t""\t""\t""unsigned j, s;" "\n"
	"\t""\t""\t""\t""unsigned char escaped[(n - i) * 4 + 1], *e = escaped;" "\n"
	"\t""\t""\t""\t""for (j = i; j < n; j++)" "\n"
	"\t""\t""\t""\t""\t""switch (s = this->l.data[j]) {" "\n"
	"\t""\t""\t""\t""\t""\t""case 'a' ... 'z':" "\n"
	"\t""\t""\t""\t""\t""\t""case 'A' ... 'Z':" "\n"
	"\t""\t""\t""\t""\t""\t""case '0' ... '9':" "\n"
	"\t""\t""\t""\t""\t""\t""case '+':" "\n"
	"\t""\t""\t""\t""\t""\t""case ':':" "\n"
	"\t""\t""\t""\t""\t""\t""case '.':" "\n"
	"\t""\t""\t""\t""\t""\t""case '!':" "\n"
	"\t""\t""\t""\t""\t""\t""\t""*e++ = s;" "\n"
	"\t""\t""\t""\t""\t""\t""\t""break;" "\n"
	"\t""\t""\t""\t""\t""\t""case '\\n':" "\n"
	"\t""\t""\t""\t""\t""\t""\t""*e++ = '\\\\';" "\n"
	"\t""\t""\t""\t""\t""\t""\t""*e++ = 'n';" "\n"
	"\t""\t""\t""\t""\t""\t""break;" "\n"
	"\t""\t""\t""\t""\t""\t""default:" "\n"
	"\t""\t""\t""\t""\t""\t""\t""printf(\"s = %c\\n\", s);" "\n"
	"\t""\t""\t""\t""\t""\t""\t""assert(!\"TODO\");" "\n"
	"\t""\t""\t""\t""\t""\t""\t""break;" "\n"
	"\t""\t""\t""\t""\t""}" "\n"
	"\t""\t""\t""\t""*e = 0;" "\n"
	"\t""\t""\t""\t""ddprintf(this, \"c == %u (%s)\\n\", c, escaped);" "\n"
	"\t""\t""\t""}" "\n"
	"\t""\t""\t""" "\n"
	"\t""\t""\t""a = (c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0) ?: (l < N( zebu_defaults) ? zebu_defaults[l] : 0);" "\n"
	"\t""\t""}" "\n"
	"\t""\t""else" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""ddprintf(this, \"c == <EOF>\\n\");" "\n"
	"\t""\t""\t""a = 0;" "\n"
	"\t""\t""}" "\n"
	"\t""\t""" "\n"
	"\t""\t""b = (l < N(zebu_accepts) ? zebu_accepts[l] : 0);" "\n"
	"\t""\t""" "\n"
	"\t""\t""if (a)" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""if (b)" "\n"
	"\t""\t""\t""{" "\n"
	"\t""\t""\t""\t""l = a, t = b, f = i++;" "\n"
	"\t""\t""\t""\t""ddprintf(this, \"l = %u, t == %u, f = %u (saved)\\n\", l, t, f);" "\n"
	"\t""\t""\t""}" "\n"
	"\t""\t""\t""else" "\n"
	"\t""\t""\t""{" "\n"
	"\t""\t""\t""\t""l = a, i++;" "\n"
	"\t""\t""\t""\t""ddprintf(this, \"l == %u\\n\", l);" "\n"
	"\t""\t""\t""}" "\n"
	"\t""\t""}" "\n"
	"\t""\t""else if (b)" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""process_token(this, b);" "\n"
	"\t""\t""\t""l = zebu_starts[this->y.data[this->y.n - 1]], f = i + 1, t = 0;" "\n"
	"\t""\t""\t""ddprintf(this, \"l == %u, f = %u, t = %u\\n\", l, f, t);" "\n"
	"\t""\t""\t""if (f >= n) break;" "\n"
	"\t""\t""}" "\n"
	"\t""\t""else if (t)" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""process_token(this, t);" "\n"
	"\t""\t""\t""l = zebu_starts[this->y.data[this->y.n - 1]], i = f, t = 0;" "\n"
	"\t""\t""\t""ddprintf(this, \"l == %u, i = %u, t = %u\\n\", l, i, t);" "\n"
	"\t""\t""}" "\n"
	"\t""\t""else" "\n"
	"\t""\t""{" "\n"
	"\t""\t""\t""assert(!\"TODO\");" "\n"
	"\t""\t""}" "\n"
	"\t""}" "\n"
	"\t""" "\n"
	"\t""process_token(this, 1);" "\n"
	"}" "\n"
	"" "\n"
	"void free_zebu_state(struct zebu_state* this) {" "\n"
	"\t""free(this->y.data);" "\n"
	"\t""free(this->l.data);" "\n"
	"\t""free(this);" "\n"
	"}" "\n"

"";

const char parser_header[] = ""
	"struct <PREFIX>_state;" "\n"

	"struct <PREFIX>_state* new_<PREFIX>_state();" "\n"

	"void <PREFIX>_reset(struct <PREFIX>_state* this);" "\n"

	"void <PREFIX>_parse(struct <PREFIX>_state* this, const unsigned char* text, size_t length);" "\n"

	"void <PREFIX>_parse_EOF(struct <PREFIX>_state* this);" "\n"

	"void free_<PREFIX>_state(struct <PREFIX>_state* this);" "\n"
"";


















