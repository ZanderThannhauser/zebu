const char* myreadline_with_driver_source = ""
	"" "\n"
	"#include <string.h>" "\n"
	"#include <stdbool.h>" "\n"
	"#include <stdlib.h>" "\n"
	"#include <assert.h>" "\n"
	"#include <termios.h>" "\n"
	"#include <unistd.h>" "\n"
	"#include <stdio.h>" "\n"
	"" "\n"
	"static const enum state {" "\n"
	"\ts_reject," "\n"
	"\ts_accept," "\n"
	"\t" "\n"
	"\ts_start," "\n"
	"\t" "\n"
	"\ts_escape," "\n"
	"\ts_csi," "\n"
	"\t" "\n"
	"\ts_insert," "\n"
	"\ts_backspace," "\n"
	"\t" "\n"
	"\ts_move_up," "\n"
	"\ts_move_down," "\n"
	"\ts_move_left," "\n"
	"\ts_move_right," "\n"
	"\ts_move_leftmost," "\n"
	"\ts_move_rightmost," "\n"
	"\t" "\n"
	"\tnumber_of_states," "\n"
	"} lookup[number_of_states][256] = {" "\n"
	"\t[s_start][\'a\' ... \'z\'] = s_insert," "\n"
	"\t[s_start][\'A\' ... \'Z\'] = s_insert," "\n"
	"\t[s_start][\'0\' ... \'9\'] = s_insert," "\n"
	"\t[s_start][\' \'] = s_insert," "\n"
	"\t" "\n"
	"\t[s_start][0x7F] = s_backspace," "\n"
	"\t" "\n"
	"\t[s_start][0x1B] = s_escape," "\n"
	"\t" "\n"
	"\t[s_escape][\'[\'] = s_csi," "\n"
	"\t" "\n"
	"\t[s_csi][\'A\'] = s_move_up," "\n"
	"\t[s_csi][\'B\'] = s_move_down," "\n"
	"\t[s_csi][\'D\'] = s_move_left," "\n"
	"\t[s_csi][\'C\'] = s_move_right," "\n"
	"\t" "\n"
	"\t[s_csi][\'H\'] = s_move_leftmost," "\n"
	"\t[s_csi][\'F\'] = s_move_rightmost," "\n"
	"};" "\n"
	"" "\n"
	"int main()" "\n"
	"{" "\n"
	"\t#if 0" "\n"
	"\tif (!isatty(0))" "\n"
	"\t{" "\n"
	"\t\tassert(!\"TODO\");" "\n"
	"\t}" "\n"
	"\t#endif" "\n"
	"\t" "\n"
	"\t// disable ICANON:" "\n"
	"\t{" "\n"
	"\t\tstruct termios termios;" "\n"
	"\t\ttcgetattr(0, &termios);" "\n"
	"\t\ttermios.c_lflag &= ~ICANON;" "\n"
	"\t\ttermios.c_lflag &= ~ECHO;" "\n"
	"\t\ttcsetattr(0, TCSAFLUSH, &termios);" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\tstruct {" "\n"
	"\t\tstruct a {" "\n"
	"\t\t\tstruct {" "\n"
	"\t\t\t\tunsigned char red, green, blue;" "\n"
	"\t\t\t} foreground, background;" "\n"
	"\t\t\tchar codepoint;" "\n"
	"\t\t}* data;" "\n"
	"\t\tunsigned size;" "\n"
	"\t\tunsigned cursor;" "\n"
	"\t} current = {}, published = {};" "\n"
	"\t" "\n"
	"\tvoid republish()" "\n"
	"\t{" "\n"
	"\t\tif (published.size < current.size)" "\n"
	"\t\t{" "\n"
	"\t\t\tfflush(stdout);" "\n"
	"\t\t\t" "\n"
	"\t\t\tpublished.data = realloc(published.data, sizeof(*published.data) * current.size);" "\n"
	"\t\t\tmemset(published.data + published.size, 0, sizeof(*published.data) * (current.size - published.size));" "\n"
	"\t\t\tpublished.size = current.size;" "\n"
	"\t\t}" "\n"
	"\t\t" "\n"
	"\t\tbool changed = false;" "\n"
	"\t\t" "\n"
	"\t\tfor (unsigned i = 0, n = current.size; i < n; i++)" "\n"
	"\t\t{" "\n"
	"\t\t\tstruct a* c = &current.data[i], *p = &published.data[i];" "\n"
	"\t\t\t" "\n"
	"\t\t\tif (false" "\n"
	"\t\t\t\t|| c->foreground.red   != p->foreground.red" "\n"
	"\t\t\t\t|| c->foreground.green != p->foreground.green" "\n"
	"\t\t\t\t|| c->foreground.blue  != p->foreground.blue" "\n"
	"\t\t\t\t|| c->background.red   != p->background.red" "\n"
	"\t\t\t\t|| c->background.green != p->background.green" "\n"
	"\t\t\t\t|| c->background.blue  != p->background.blue" "\n"
	"\t\t\t\t|| c->codepoint        != p->codepoint)" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tprintf(\"\\e[%uG\\e[38;2;%u;%u;%u;48;2;%u;%u;%um%c\", i + 1," "\n"
	"\t\t\t\t\tc->foreground.red," "\n"
	"\t\t\t\t\tc->foreground.green," "\n"
	"\t\t\t\t\tc->foreground.blue," "\n"
	"\t\t\t\t\tc->background.red," "\n"
	"\t\t\t\t\tc->background.green," "\n"
	"\t\t\t\t\tc->background.blue," "\n"
	"\t\t\t\t\tc->codepoint);" "\n"
	"\t\t\t\t*p = *c;" "\n"
	"\t\t\t\tchanged = true;" "\n"
	"\t\t\t}" "\n"
	"\t\t}" "\n"
	"\t\t" "\n"
	"\t\tif (changed || published.cursor != current.cursor)" "\n"
	"\t\t{" "\n"
	"\t\t\tprintf(\"\\e[%uG\", current.cursor + 1);" "\n"
	"\t\t\tpublished.cursor = current.cursor;" "\n"
	"\t\t\tfflush(stdout);" "\n"
	"\t\t}" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\tvoid set(unsigned index, struct a a)" "\n"
	"\t{" "\n"
	"\t\twhile (index >= current.size)" "\n"
	"\t\t{" "\n"
	"\t\t\tcurrent.size = current.size << 1 ?: 1;" "\n"
	"\t\t\tcurrent.data = realloc(current.data, sizeof(*current.data) * current.size);" "\n"
	"\t\t}" "\n"
	"\t\t" "\n"
	"\t\tcurrent.data[index] = a;" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\tset(0, (struct a) { {100, 100, 100}, {0, 0, 0}, \'>\'});" "\n"
	"\tset(1, (struct a) { {150, 150, 150}, {0, 0, 0}, \'>\'});" "\n"
	"\tset(2, (struct a) { {200, 200, 200}, {0, 0, 0}, \'>\'});" "\n"
	"\t" "\n"
	"\tset(3, (struct a) { {255, 255, 255}, {0, 0, 0}, \' \'});" "\n"
	"\t" "\n"
	"\tcurrent.cursor = 4;" "\n"
	"\t" "\n"
	"\trepublish();" "\n"
	"\t" "\n"
	"\tstruct {" "\n"
	"\t\tchar* data;" "\n"
	"\t\tunsigned n, cap;" "\n"
	"\t} text = {};" "\n"
	"\t" "\n"
	"\tunsigned insertion_point = 0;" "\n"
	"\t" "\n"
	"\tenum state state = s_start;" "\n"
	"\t" "\n"
	"\tfor (unsigned char c; read(0, &c, 1) == 1; )" "\n"
	"\t{" "\n"
	"\t\tswitch ((state = lookup[state][c]))" "\n"
	"\t\t{" "\n"
	"\t\t\tcase s_accept:" "\n"
	"\t\t\t\tassert(!\"TODO\");" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_reject:" "\n"
	"\t\t\t\tprintf(\"c == 0x%hhx!\\n\", c);" "\n"
	"\t\t\t\tassert(!\"TODO\");" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_escape: break;" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_csi: break;" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_insert:" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tif (text.n == text.cap)" "\n"
	"\t\t\t\t{" "\n"
	"\t\t\t\t\ttext.cap = text.cap << 1 ?: 1;" "\n"
	"\t\t\t\t\ttext.data = realloc(text.data, sizeof(*text.data) * text.cap);" "\n"
	"\t\t\t\t}" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tmemmove(text.data + insertion_point + 1, text.data + insertion_point, text.n - insertion_point);" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\ttext.data[insertion_point++] = c, text.n++;" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tcurrent.cursor++;" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tfor (unsigned i = 0, n = text.n; i < n; i++)" "\n"
	"\t\t\t\t\tset(i + 4, (struct a) { {240, 240, 240}, {0, 0, 0}, text.data[i]});" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\trepublish();" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tstate = s_start;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_backspace:" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tif (insertion_point > 0)" "\n"
	"\t\t\t\t{" "\n"
	"\t\t\t\t\tmemmove(text.data + insertion_point - 1, text.data + insertion_point, text.n - insertion_point);" "\n"
	"\t\t\t\t\t" "\n"
	"\t\t\t\t\ttext.n--;" "\n"
	"\t\t\t\t\t" "\n"
	"\t\t\t\t\tinsertion_point--;" "\n"
	"\t\t\t\t\t" "\n"
	"\t\t\t\t\tcurrent.cursor--;" "\n"
	"\t\t\t\t\t" "\n"
	"\t\t\t\t\tfor (unsigned i = 0, n = text.n; i < n; i++)" "\n"
	"\t\t\t\t\t\tset(i + 4, (struct a) { {240, 240, 240}, {0, 0, 0}, text.data[i]});" "\n"
	"\t\t\t\t\t" "\n"
	"\t\t\t\t\tset(text.n + 4, (struct a) { {240, 240, 240}, {0, 0, 0}, \' \'});" "\n"
	"\t\t\t\t\t" "\n"
	"\t\t\t\t\trepublish();" "\n"
	"\t\t\t\t}" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tstate = s_start;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_move_up:" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tstate = s_start;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_move_down:" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tstate = s_start;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_move_left:" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tif (insertion_point > 0)" "\n"
	"\t\t\t\t{" "\n"
	"\t\t\t\t\tinsertion_point--, current.cursor--;" "\n"
	"\t\t\t\t\t" "\n"
	"\t\t\t\t\trepublish();" "\n"
	"\t\t\t\t}" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tstate = s_start;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_move_right:" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tif (insertion_point < text.n)" "\n"
	"\t\t\t\t{" "\n"
	"\t\t\t\t\tinsertion_point++, current.cursor++;" "\n"
	"\t\t\t\t\t" "\n"
	"\t\t\t\t\trepublish();" "\n"
	"\t\t\t\t}" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tstate = s_start;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_move_leftmost:" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tinsertion_point = 0, current.cursor = 4;" "\n"
	"\t\t\t\trepublish();" "\n"
	"\t\t\t\tstate = s_start;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase s_move_rightmost:" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tinsertion_point = text.n, current.cursor = text.n + 4;" "\n"
	"\t\t\t\trepublish();" "\n"
	"\t\t\t\tstate = s_start;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tdefault:" "\n"
	"\t\t\t\tassert(!\"TODO\");" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t}" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\t// enable ICANON:" "\n"
	"\t{" "\n"
	"\t\tstruct termios termios;" "\n"
	"\t\ttcgetattr(0, &termios);" "\n"
	"\t\ttermios.c_lflag |= ICANON;" "\n"
	"\t\ttermios.c_lflag |= ECHO;" "\n"
	"\t\ttcsetattr(0, TCSAFLUSH, &termios);" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\treturn 0;" "\n"
	"}" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"";
