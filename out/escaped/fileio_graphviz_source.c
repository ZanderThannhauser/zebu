const char* fileio_graphviz_source = ""
	"" "\n"
	"#define _GNU_SOURCE" "\n"
	"" "\n"
	"#include <string.h>" "\n"
	"#include <unistd.h>" "\n"
	"#include <stdlib.h>" "\n"
	"#include <assert.h>" "\n"
	"#include <stdio.h>" "\n"
	"#include <errno.h>" "\n"
	"" "\n"
	"#define argv0 (program_invocation_name)" "\n"
	"" "\n"
	"#define N(array) (sizeof(array) / sizeof(*array))" "\n"
	"" "\n"
	"void* smalloc(size_t size)" "\n"
	"{" "\n"
	"\tvoid* ptr = malloc(size);" "\n"
	"\tif (!ptr)" "\n"
	"\t{" "\n"
	"\t\tfprintf(stderr, \"%s: malloc(%lu): %m\\n\", argv0, size);" "\n"
	"\t\texit(1);" "\n"
	"\t}" "\n"
	"\treturn ptr;" "\n"
	"}" "\n"
	"" "\n"
	"void* srealloc(void* ptr, size_t size)" "\n"
	"{" "\n"
	"\tassert(!\"TODO\");" "\n"
	"}" "\n"
	"" "\n"
	"void* smemdup(const void* src, size_t size)" "\n"
	"{" "\n"
	"\tvoid* new = smalloc(size);" "\n"
	"\tmemcpy(new, src, size);" "\n"
	"\treturn new;" "\n"
	"}" "\n"
	"" "\n"
	"FILE* sfopen(const char* path, const char* mode)" "\n"
	"{" "\n"
	"\tFILE* stream = fopen(path, mode);" "\n"
	"\t" "\n"
	"\tif (!stream)" "\n"
	"\t{" "\n"
	"\t\tfprintf(stderr, \"%s: fopen(\\\"%s\\\", \\\"%s\\\"): %m\\n\", argv0, path, mode);" "\n"
	"\t\texit(1);" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\treturn stream;" "\n"
	"}" "\n"
	"" "\n"
	"struct cmdln" "\n"
	"{" "\n"
	"\tconst char* input;" "\n"
	"\tconst char* output;" "\n"
	"};" "\n"
	"" "\n"
	"void usage(int code)" "\n"
	"{" "\n"
	"\tfprintf(stderr, \"usage: \"" "\n"
	"\t\t\"%s <path/to/input/file> -o <path/to/output/file.dot>\\n\", argv0);" "\n"
	"\texit(code);" "\n"
	"}" "\n"
	"" "\n"
	"struct cmdln* process_cmdln(int argc, char* const* argv)" "\n"
	"{" "\n"
	"\tint opt;" "\n"
	"\t" "\n"
	"\tconst char* input = NULL;" "\n"
	"\tconst char* output = NULL;" "\n"
	"\t" "\n"
	"\twhile ((opt = getopt(argc, argv, \"ho:\")) != -1)" "\n"
	"\t{" "\n"
	"\t\tswitch (opt)" "\n"
	"\t\t{" "\n"
	"\t\t\tcase \'h\':" "\n"
	"\t\t\t\tusage(0);" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t" "\n"
	"\t\t\tcase \'o\':" "\n"
	"\t\t\t\toutput = optarg;" "\n"
	"\t\t\t\tbreak;" "\n"
	"\t\t\t" "\n"
	"\t\t\tdefault:" "\n"
	"\t\t\t\tusage(1);" "\n"
	"\t\t}" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\tinput = argv[optind++];" "\n"
	"\t" "\n"
	"\tif (!input || !output)" "\n"
	"\t\tusage(1);" "\n"
	"\t" "\n"
	"\tstruct cmdln* retval = smalloc(sizeof(*retval));" "\n"
	"\tretval->input = input;" "\n"
	"\tretval->output = output;" "\n"
	"\treturn retval;" "\n"
	"}" "\n"
	"" "\n"
	"struct value" "\n"
	"{" "\n"
	"\tunsigned shifton;" "\n"
	"\tenum {" "\n"
	"\t\tvk_token," "\n"
	"\t\tvk_grammar," "\n"
	"\t\tvk_EOF," "\n"
	"\t} kind;" "\n"
	"\tunion {" "\n"
	"\t\tstruct {" "\n"
	"\t\t\tunsigned char* data;" "\n"
	"\t\t\tunsigned n;" "\n"
	"\t\t} t;" "\n"
	"\t\tstruct {" "\n"
	"\t\t\tconst char* name;" "\n"
	"\t\t\tstruct value** values;" "\n"
	"\t\t\tunsigned n;" "\n"
	"\t\t} g;" "\n"
	"\t};" "\n"
	"};" "\n"
	"" "\n"
	"struct value* new_token(unsigned shifton, unsigned char* data, unsigned n)" "\n"
	"{" "\n"
	"\tstruct value* value = smalloc(sizeof(*value));" "\n"
	"\t" "\n"
	"\tvalue->shifton = shifton;" "\n"
	"\t" "\n"
	"\tvalue->kind = vk_token;" "\n"
	"\t" "\n"
	"\tvalue->t.data = smemdup(data, sizeof(*data) * n);" "\n"
	"\tvalue->t.n = n;" "\n"
	"\t" "\n"
	"\treturn value;" "\n"
	"}" "\n"
	"" "\n"
	"struct value* new_EOF_token(unsigned shifton)" "\n"
	"{" "\n"
	"\tstruct value* value = smalloc(sizeof(*value));" "\n"
	"\t" "\n"
	"\tvalue->shifton = shifton;" "\n"
	"\t" "\n"
	"\tvalue->kind = vk_EOF;" "\n"
	"\t" "\n"
	"\treturn value;" "\n"
	"}" "\n"
	"" "\n"
	"struct lexer { unsigned char* data, n, cap; };" "\n"
	"" "\n"
	"struct value* read_token(struct lexer* lexer, FILE* stream, unsigned state)" "\n"
	"{" "\n"
	"\tvoid append(unsigned char c)" "\n"
	"\t{" "\n"
	"\t\twhile (lexer->n + 1 >= lexer->cap)" "\n"
	"\t\t{" "\n"
	"\t\t\tlexer->cap = lexer->cap << 1 ?: 1;" "\n"
	"\t\t\tlexer->data = realloc(lexer->data, lexer->cap);" "\n"
	"\t\t}" "\n"
	"\t\t" "\n"
	"\t\tlexer->data[lexer->n++] = c;" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\tunsigned i = 0;" "\n"
	"\t" "\n"
	"\tunsigned token = 0, fallback;" "\n"
	"\t" "\n"
	"\twhile (1)" "\n"
	"\t{" "\n"
	"\t\tunsigned next, accept, c;" "\n"
	"\t\t" "\n"
	"\t\tif (i < lexer->n)" "\n"
	"\t\t{" "\n"
	"\t\t\tc = lexer->data[i];" "\n"
	"\t\t\t" "\n"
	"\t\t\tnext = 0" "\n"
	"\t\t\t\t?: (c < N(*<PREFIX>_lexer) ? <PREFIX>_lexer[state][c] : 0)" "\n"
	"\t\t\t\t?: (state < N( <PREFIX>_defaults) ? <PREFIX>_defaults[state] : 0);" "\n"
	"\t\t}" "\n"
	"\t\telse if ((c = getc(stream)) != EOF)" "\n"
	"\t\t{" "\n"
	"\t\t\tappend(c);" "\n"
	"\t\t\t" "\n"
	"\t\t\tnext = 0" "\n"
	"\t\t\t\t?: (c < N(*<PREFIX>_lexer) ? <PREFIX>_lexer[state][c] : 0)" "\n"
	"\t\t\t\t?: (state < N( <PREFIX>_defaults) ? <PREFIX>_defaults[state] : 0);" "\n"
	"\t\t}" "\n"
	"\t\telse" "\n"
	"\t\t{" "\n"
	"\t\t\tc = EOF;" "\n"
	"\t\t\tnext = state < N(<PREFIX>_EOFs) ? <PREFIX>_EOFs[state] : 0;" "\n"
	"\t\t}" "\n"
	"\t\t" "\n"
	"\t\taccept = (state < N(<PREFIX>_accepts) ? <PREFIX>_accepts[state] : 0);" "\n"
	"\t\t" "\n"
	"\t\tif (next)" "\n"
	"\t\t{" "\n"
	"\t\t\tif (accept)" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tstate = next, token = accept, fallback = i++;" "\n"
	"\t\t\t}" "\n"
	"\t\t\telse" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tstate = next, i++;" "\n"
	"\t\t\t}" "\n"
	"\t\t}" "\n"
	"\t\telse if (accept)" "\n"
	"\t\t{" "\n"
	"\t\t\tif (!lexer->n)" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tlexer->n = 0;" "\n"
	"\t\t\t\treturn new_EOF_token(accept);" "\n"
	"\t\t\t}" "\n"
	"\t\t\telse" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tstruct value* retval = new_token(accept, lexer->data, lexer->n - 1);" "\n"
	"\t\t\t\tlexer->n = 0;" "\n"
	"\t\t\t\tif (c != EOF) lexer->data[lexer->n++] = c;" "\n"
	"\t\t\t\treturn retval;" "\n"
	"\t\t\t}" "\n"
	"\t\t}" "\n"
	"\t\telse if (token)" "\n"
	"\t\t{" "\n"
	"\t\t\tstruct value* retval = new_token(token, lexer->data, fallback);" "\n"
	"\t\t\tmemmove(lexer->data, lexer->data + fallback, lexer->n - fallback);" "\n"
	"\t\t\tlexer->n -= fallback;" "\n"
	"\t\t\treturn retval;" "\n"
	"\t\t}" "\n"
	"\t\telse" "\n"
	"\t\t{" "\n"
	"\t\t\tassert(!\"168\");" "\n"
	"\t\t}" "\n"
	"\t}" "\n"
	"}" "\n"
	"" "\n"
	"struct value* new_grammar(" "\n"
	"\tunsigned shifton," "\n"
	"\tconst char* name," "\n"
	"\tstruct value** values," "\n"
	"\tunsigned n_values)" "\n"
	"{" "\n"
	"\tstruct value* v = smalloc(sizeof(*v));" "\n"
	"\t" "\n"
	"\tv->shifton = shifton;" "\n"
	"\t" "\n"
	"\tv->kind = vk_grammar;" "\n"
	"\t" "\n"
	"\tv->g.name = name;" "\n"
	"\tv->g.values = smemdup(values, sizeof(*values) * n_values);" "\n"
	"\tv->g.n = n_values;" "\n"
	"\t" "\n"
	"\treturn v;" "\n"
	"}" "\n"
	"" "\n"
	"void free_value(struct value* v)" "\n"
	"{" "\n"
	"\tswitch (v->kind)" "\n"
	"\t{" "\n"
	"\t\tcase vk_token:" "\n"
	"\t\t\tfree(v->t.data);" "\n"
	"\t\t\tbreak;" "\n"
	"\t\t" "\n"
	"\t\tcase vk_grammar:" "\n"
	"\t\t\tfor (unsigned i = 0, n = v->g.n; i < n; i++)" "\n"
	"\t\t\t\tfree_value(v->g.values[i]);" "\n"
	"\t\t\tfree(v->g.values);" "\n"
	"\t\t\tbreak;" "\n"
	"\t\t" "\n"
	"\t\tcase vk_EOF:" "\n"
	"\t\t\tbreak;" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\tfree(v);" "\n"
	"}" "\n"
	"" "\n"
	"struct value* parse(FILE* stream)" "\n"
	"{" "\n"
	"\tstruct { unsigned* data, n, cap; } stack = {};" "\n"
	"\tstruct { struct value** data; unsigned n, cap; } values = {};" "\n"
	"\tstruct lexer lexer = {};" "\n"
	"\t" "\n"
	"\tvoid push(unsigned y)" "\n"
	"\t{" "\n"
	"\t\tif (stack.n + 1 >= stack.cap)" "\n"
	"\t\t{" "\n"
	"\t\t\tstack.cap = stack.cap << 1 ?: 1;" "\n"
	"\t\t\tstack.data = realloc(stack.data, sizeof(*stack.data) * stack.cap);" "\n"
	"\t\t}" "\n"
	"\t\tstack.data[stack.n++] = y;" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\tvoid push_value(struct value* v)" "\n"
	"\t{" "\n"
	"\t\tif (values.n + 1 >= values.cap)" "\n"
	"\t\t{" "\n"
	"\t\t\tvalues.cap = values.cap << 1 ?: 1;" "\n"
	"\t\t\tvalues.data = realloc(values.data, sizeof(*values.data) * values.cap);" "\n"
	"\t\t}" "\n"
	"\t\tvalues.data[values.n++] = v;" "\n"
	"\t}" "\n"
	"\t" "\n"
	"\tpush(1);" "\n"
	"\t" "\n"
	"\tstruct value* g = NULL, *t = read_token(&lexer, stream, 1);" "\n"
	"\t" "\n"
	"\twhile (1)" "\n"
	"\t{" "\n"
	"\t\tunsigned y = stack.data[stack.n - 1], s, r;" "\n"
	"\t\t" "\n"
	"\t\tunsigned w = g ? g->shifton : t ? t->shifton : 0;" "\n"
	"\t\tif (y < N(<PREFIX>_shifts) && w < N(*<PREFIX>_shifts) && (s = <PREFIX>_shifts[y][w]))" "\n"
	"\t\t{" "\n"
	"\t\t\tpush_value(g ?: t);" "\n"
	"\t\t\tpush(s);" "\n"
	"\t\t\tif (g) g = NULL;" "\n"
	"\t\t\telse t = read_token(&lexer, stream, <PREFIX>_starts[s]);" "\n"
	"\t\t}" "\n"
	"\t\telse if (y < N(<PREFIX>_reduces) && w < N(*<PREFIX>_reduces) && (r = <PREFIX>_reduces[y][w]))" "\n"
	"\t\t{" "\n"
	"\t\t\tassert(!g);" "\n"
	"\t\t\tif (r == start_grammar_id)" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tfree_value(t);" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tg = new_grammar(r, zebu_grammar_names[r], values.data, values.n);" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\tfree(stack.data);" "\n"
	"\t\t\t\tfree(lexer.data);" "\n"
	"\t\t\t\tfree(values.data);" "\n"
	"\t\t\t\t" "\n"
	"\t\t\t\treturn g;" "\n"
	"\t\t\t}" "\n"
	"\t\t\telse" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tunsigned p = <PREFIX>_popcounts[y][w];" "\n"
	"\t\t\t\tg = new_grammar(r, zebu_grammar_names[r], values.data + values.n - p, p);" "\n"
	"\t\t\t\tstack.n -= p, values.n -= p;" "\n"
	"\t\t\t}" "\n"
	"\t\t}" "\n"
	"\t\telse" "\n"
	"\t\t{" "\n"
	"\t\t\tassert(!\"266\");" "\n"
	"\t\t}" "\n"
	"\t}" "\n"
	"}" "\n"
	"" "\n"
	"void dotout(struct value* value, FILE* stream)" "\n"
	"{" "\n"
	"\tswitch (value->kind)" "\n"
	"\t{" "\n"
	"\t\tcase vk_token:" "\n"
	"\t\t{" "\n"
	"\t\t\tfprintf(stream, \"\\\"%p\\\" [ label = \\\"\", value);" "\n"
	"\t\t\t" "\n"
	"\t\t\tfor (unsigned i = 0, u, n = value->t.n; i < n; i++)" "\n"
	"\t\t\t\tswitch ((u = value->t.data[i]))" "\n"
	"\t\t\t\t{" "\n"
	"\t\t\t\t\tcase \'\\n\': fprintf(stream, \"&#%u;&#%u;&#%u;\", \'\\\\\', \'\\\\\', \'n\'); break;" "\n"
	"\t\t\t\t\tcase \'\\t\': fprintf(stream, \"&#%u;&#%u;&#%u;\", \'\\\\\', \'\\\\\', \'t\'); break;" "\n"
	"\t\t\t\t\tdefault: fprintf(stream, \"&#%u;\", u); break;" "\n"
	"\t\t\t\t}" "\n"
	"\t\t\t" "\n"
	"\t\t\tfprintf(stream, \"\\\" ];\\n\");" "\n"
	"\t\t\tbreak;" "\n"
	"\t\t}" "\n"
	"\t\t" "\n"
	"\t\tcase vk_grammar:" "\n"
	"\t\t{" "\n"
	"\t\t\tfprintf(stream, \"\\\"%p\\\" [ label = \\\"%s\\\" ];\", value, value->g.name);" "\n"
	"\t\t\t" "\n"
	"\t\t\tfor (unsigned i = 0, n = value->g.n; i < n; i++)" "\n"
	"\t\t\t{" "\n"
	"\t\t\t\tstruct value* e = value->g.values[i];" "\n"
	"\t\t\t\tdotout(e, stream);" "\n"
	"\t\t\t\tfprintf(stream, \"\\\"%p\\\" -> \\\"%p\\\"\\n\", value, e);" "\n"
	"\t\t\t}" "\n"
	"\t\t\tbreak;" "\n"
	"\t\t}" "\n"
	"\t\t" "\n"
	"\t\tcase vk_EOF:" "\n"
	"\t\t\tfprintf(stream, \"\\\"%p\\\" [ label = \\\"<EOF>\\\" ];\", value);" "\n"
	"\t\t\tbreak;" "\n"
	"\t}" "\n"
	"}" "\n"
	"" "\n"
	"int main(int argc, char* const* argv)" "\n"
	"{" "\n"
	"\tstruct cmdln* cmdln = process_cmdln(argc, argv);" "\n"
	"\t" "\n"
	"\tFILE* input = sfopen(cmdln->input, \"r\");" "\n"
	"\t" "\n"
	"\tstruct value* ptree = parse(input);" "\n"
	"\t" "\n"
	"\tfclose(input);" "\n"
	"\t" "\n"
	"\tFILE* output = sfopen(cmdln->output, \"w\");" "\n"
	"\t" "\n"
	"\tfprintf(output, \"digraph {\\n\");" "\n"
	"\t" "\n"
	"\tfprintf(output, \"rankdir = LR;\\n\");" "\n"
	"\t" "\n"
	"\tfprintf(output, \"node [shape = box];\\n\");" "\n"
	"\t" "\n"
	"\tdotout(ptree, output);" "\n"
	"\t" "\n"
	"\tfprintf(output, \"}\\n\");" "\n"
	"\t" "\n"
	"\tfclose(output);" "\n"
	"\t" "\n"
	"\tfree_value(ptree);" "\n"
	"\t" "\n"
	"\tfree(cmdln);" "\n"
	"\t" "\n"
	"\treturn 0;" "\n"
	"}" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"" "\n"
	"";
